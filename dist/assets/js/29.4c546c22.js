(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{432:function(t,s,a){"use strict";a.r(s);var v=a(0),_=Object(v.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("jetson nano")])]),t._v(" "),s("h2",{attrs:{id:"文件操作与系统调用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#文件操作与系统调用"}},[t._v("#")]),t._v(" 文件操作与系统调用")]),t._v(" "),s("p",[t._v("在Linux系统中有一个重要的概念：一切皆文件，它把一切资源都看作是文件，包括硬件设备，通常称为设备文件。前面我们也尝试过通过脚本读写文件的方式，实现了对硬件的访问。所以如果不了解Linux的文件操作，那想要点亮板卡的LED灯都费劲！")]),t._v(" "),s("p",[t._v("本章通过C标准库及系统调用的方式操作文件，揭示用户应用程序、C标准库与系统调用之间的关系。")]),t._v(" "),s("h2",{attrs:{id:"_1-存储设备文件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-存储设备文件"}},[t._v("#")]),t._v(" 1.存储设备文件")]),t._v(" "),s("p",[t._v("提到文件系统时，我们首先想到的通常是Windows下的FAT32、NTFS、exFAT以及Linux下常用的ext2、ext3和ext4的类型格式。这些文件系统都是为了解决如何高效管理存储器空间的问题而诞生的。")]),t._v(" "),s("p",[t._v("从EEPROM、Nor FLASH、NAND FLASH、eMMC到机械硬盘，各种各样的存储器本质就是具有多个能够 存储0和1数据单元的设备，存储内容时，程序需要直接访问这些存储单元的物理地址来保存内容。这样直接 存储数据会带来极大的不便，如难以记录有效数据的位置，难以确定存储介质的剩余空间，以及应以何 种格式来解读数据。就如同一个巨大的图书馆无人管理，杂乱无章地堆放着各种书籍，难以查找。")]),t._v(" "),s("p",[t._v("为了高效地存储和管理数据，文件系统在存储介质上建立了一种组织结构，这些结构包括操作系 统引导区、目录和文件，就如同图书馆给不同类的书籍进行分类、编号，放在不同的书架上。不同的管理 理念引出了不同的文件系统标准，上述的 FAT32、 NTFS、 exFAT、ext2/3/4就是指不同类型的 标准，除此之外，还有专门针对NAND类型设备 的文件系统jffs2、yaffs2等等。")]),t._v(" "),s("p",[t._v("正是有了文件系统，计算机上的数据才能以文件的形式呈现给用户。关于文件系统的基本概 念，学习野火《STM32库开发实战指南》或《i.MX RT库开发实战指南》中Fatfs文件系统章节 的相关内容，可以非常清楚地了解使用MCU直接记录数据与通过文件系统记录文件时的差异。")]),t._v(" "),s("p",[t._v("下面简单介绍一下各种不同标准文件系统的特性：")]),t._v(" "),s("ul",[s("li",[t._v("FAT32格式：兼容性好， STM32等MCU也可以通过Fatfs支持FAT32文件系统，大部分SD卡或U盘出厂 默认使用的就是FAT32文件系统。它的主要缺点是技术老旧，单个文件不能超过4GB，非日志型文件系统。")]),t._v(" "),s("li",[t._v("NTFS格式：单个文件最大支持256TB、支持长文件名、服务器文件管理权限等，而且NTFS是日志型 文件系统。但由于是日志型文件系统，会记录详细的读写操作，相对来说会加快FLASH存储器的损 耗。文件系统的日志功能是指，它会把文件系统的操作记录在磁盘的某个分区，当系统发生故障时，能够 尽最大的努力保证数据的完整性。")]),t._v(" "),s("li",[t._v("exFAT格式：基于FAT32改进而来，专为FLASH介质的存储器 设计（如SD卡、U盘），空间浪费少。单个文件最大支持16EB，非日志文件系统。")]),t._v(" "),s("li",[t._v("ext2格式：简单，文件少时性能较好，单个文件不能超过2TB。非日志文件系统。")]),t._v(" "),s("li",[t._v("ext3格式：相对于ext2主要增加了支持日志功能。")]),t._v(" "),s("li",[t._v("ext4格式：从ext3改进而来，ext3实际是ext4的子集。它支持1EB的分区，单个文件最大支 持16TB，支持无限的子目录数量，使用延迟分配策略优化了文件的数据块分配，允许自主控制是否使用日志的功能。")]),t._v(" "),s("li",[t._v("jffs2和yaffs2格式： jffs2和yaffs2是专为FLASH类型存储器设计的文件 系统，它们针对FLASH存储器的特性加入了擦写平衡和掉电保护等特性。由于Nor、NAND FLASH类 型存储器的存储块的擦写次数是有限的（通常为10万次），使用这些类型的文件系统可以减少对存储器的损耗。")])]),t._v(" "),s("p",[t._v("总的来说，在Linux下，ext2适用于U盘（但为了兼容，使用得比较多的还是FAT32或exFAT），日常应用推 荐使用ext4，而ext3使用的场景大概就只剩下对ext4格式的稳定性还有疑虑的用户了，但ext4从2008年就已结束 实验期，进入稳定版了，可以放心使用。")]),t._v(" "),s("p",[t._v("Linux内核本身也支持FAT32文件系统，而使用NTFS格式则需要安装额外的工具如ntfs-3g。所以使用板卡出厂的 默认Linux系统时，把FAT32格式的U盘直接插入到板卡是可以自动挂载的，而NTFS格式的则不支持。主机上 的Ubuntu对于NTFS或FAT32的U盘都能自动识别并挂载，因为U buntu发行版安装了相应的支持。目前微软已公开exFAT文件系统的标准，且已把它开源至Linux，未来Linux可能 也默认支持exFAT。")]),t._v(" "),s("p",[t._v("对于非常在意FLASH存储器损耗的场合，则可以考虑使用jffs2或yaffs2等文件系统。")]),t._v(" "),s("p",[t._v("在Linux下，可以通过如下命令查看当前存储设备使用的文件系统：")]),t._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("df")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-T")]),t._v("\n")])])]),s("p",[s("img",{attrs:{src:"https://aniya.oss-cn-shanghai.aliyuncs.com/image-20230304123631175.png",alt:"image-20230304123631175"}})]),t._v(" "),s("h2",{attrs:{id:"_2-伪文件系统"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-伪文件系统"}},[t._v("#")]),t._v(" 2.伪文件系统")]),t._v(" "),s("p",[t._v("除了前面介绍的专门用于存储设备记录文件的文 件系统外，Linux内核还提供了procfs、sysfs和devfs等伪文件系统。")]),t._v(" "),s("p",[t._v("伪文件系统存在于内存中，通常不占用硬盘空间，它以文 件的形式，向用户提供了访问系统内核数据的接口。用户和应用程序 可以通过访问这些数据接口，得到系统的信息，而且内核允许用户修改内核的某些参数。")]),t._v(" "),s("p",[t._v("使用如下命令可以查看proc文件系统的内容：")]),t._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#查看CPU信息")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("cat")]),t._v(" /proc/cpuinfo\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#查看proc目录")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("ls")]),t._v(" /proc\n")])])]),s("p",[s("img",{attrs:{src:"https://aniya.oss-cn-shanghai.aliyuncs.com/image-20230304124452548.png",alt:"image-20230304124452548"}})]),t._v(" "),s("p",[t._v("刚才我们查看了CPU的信息，而上图表示/proc包含了非常多以数字命 名的目录，这些数字就是进程的PID号，其它文件或目录的一些说明见下表。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://aniya.oss-cn-shanghai.aliyuncs.com/image-20230304124615100.png",alt:"image-20230304124615100"}})]),t._v(" "),s("p",[t._v("刚才我们查看了CPU的信息，而上图表示/proc包含了非常多以数字命 名的目录，这些数字就是进程的PID号，其它文件或目录的一些说明见下表。")]),t._v(" "),s("p",[t._v("/proc各个文件的作用")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("文件名")]),t._v(" "),s("th",[t._v("作用")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("pid*")]),t._v(" "),s("td",[t._v("*表示的是进程的 PID 号，系统中当前运行的每一个进程都有对应的一个目录，用于记录进程所有相关信息。对于操作系统来说，一个应用程序就是一个进程")])]),t._v(" "),s("tr",[s("td",[t._v("self")]),t._v(" "),s("td",[t._v("该文件是一个软链接，指向了当前进程的目录，通过访问/proc/self/目录来获取当前进程的信息，就不用每次都获取pid")])]),t._v(" "),s("tr",[s("td",[t._v("thread-self")]),t._v(" "),s("td",[t._v("该文件也是一个软链接，指向了当前线程，访问该文件，等价于访问“当前进程pid/task/当前线程tid”的内容。。一个进程，可以包含多个线程，但至少需要一个进程，这些线程共同支撑进程的运行。")])]),t._v(" "),s("tr",[s("td",[t._v("version")]),t._v(" "),s("td",[t._v("记录了当前运行的内核版本，通常可以使用命令“uname –r”")])]),t._v(" "),s("tr",[s("td",[t._v("cpuinfo")]),t._v(" "),s("td",[t._v("记录系统中CPU的提供商和相关配置信息")])]),t._v(" "),s("tr",[s("td",[t._v("modules")]),t._v(" "),s("td",[t._v("记录了目前系统加载的模块信息")])]),t._v(" "),s("tr",[s("td",[t._v("meminfo")]),t._v(" "),s("td",[t._v("记录系统中内存的使用情况，free命令会访问该文件，来获取系统内存的空闲和已使用的数量")])]),t._v(" "),s("tr",[s("td",[t._v("filesystems")]),t._v(" "),s("td",[t._v("记录内核支持的文件系统类型，通常mount一个设备时，如果没有指定文件系统并且它无法确定文件系统类型时，mount会尝试包含在该文件中的文件系统，除了那些标有“nodev”的文件系统。")])])])]),t._v(" "),s("p",[t._v("下面我们以当前bash的进程pid目录，来了解proc文件系统的一些功能。")]),t._v(" "),s("p",[t._v("使用如下命令来查看当前bash进程的PID号")]),t._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#在主机上输入如下命令")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("ps")]),t._v("\n")])])]),s("p",[t._v("每个人计算机的PID进程不一样，")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://aniya.oss-cn-shanghai.aliyuncs.com/image-20230305172132780.png",alt:"image-20230305172132780"}})])])}),[],!1,null,null,null);s.default=_.exports}}]);